#include "javacode.h"

/*
 * Implement as the following...
 * Unit: 
 *   Becomes a class
 *   functions: 
 *      static methods within the class
 *   closures:
 *      library class
 *   formats:
 *      ? inner classes

 * Fluids:
 *    supplied as library
 */

/* static function declarations */
local String gj0ClassName(Foam foam, String name);
local String gj0ClassDocumentation(Foam foam, String name);
local JavaCodeList gj0DDef(Foam foam);
local JavaCode gj0Gen(Foam foam);
local JavaCode gj0Def(Foam foam);
local JavaCode gj0Default(Foam foam);
local JavaCode gj0Prog(Foam lhs, Foam rhs);
local JavaCode gj0ClosInit(Foam lhs, Foam rhs);
local JavaCode gj0Set(Foam lhs, Foam rhs);
local JavaCode gj0Seq(Foam seq);
local JavaCode gj0Par(Foam seq);
local JavaCode gj0Loc(Foam seq);

local JavaCode gj0SInt(Foam seq);

local JavaCode gj0CCall(Foam call);
local JavaCode gj0OCall(Foam call);

local void     gjInit(Foam foam, String name);
local String   gj0MethodName(Foam var);
local void     gj0ProgInit(Foam lhs, Foam rhs);
local void     gj0ProgFini(Foam lhs, Foam rhs);
local JavaCodeList gj0ProgCollectArgs(Foam fm);
local JavaCode     gj0ProgGenerateBody(Foam fm);
local JavaCodeList gj0ProgExceptions();
local int          gj0ProgModifiers();
local String       gj0ProgMethodName(Foam var);
local String       gj0Name(String prefix, Foam fmt, int idx);
local JavaCode     gj0ProgRetnType(Foam rhs);
local JavaCode     gj0TopConst(Foam lhs, Foam rhs);
local JavaCode     gj0Type(Foam decl);
local JavaCode     gj0TypeFrFmt(AInt id, AInt fmt);

local JavaCodeList gj0CCallCollectArgs(Foam call);
local String       gj0CCallFindMethod(Foam call) ;

/* State variables */
struct gjContext {
	int  lvl;
	Foam formats;
	Foam constants;
	Foam progParams;
	Foam progLocals;
	Foam progLhs;
};

static struct gjContext gjCtxt0;
static struct gjContext *gjContext = &gjCtxt0;

/* Functions... */

JavaCode 
gjGenJavaUnit(Foam foam, String name)
{
	JavaCodeList imps, code;
	JavaCode clss;
	String className, comment;

	gjInit(foam, name);

	className = gj0ClassName(foam, name);
	code = gj0DDef(foam->foamUnit.defs);
	comment = gj0ClassDocumentation(foam, name);

	clss = jcClass(JCO_MOD_Public, comment, 
				jcId(className), NULL, NULL, code);

	imps = jcCollectImports(clss);
	JavaCodeList ids = listNil(JavaCode);
	JavaCodeList tmp = imps;
	while (tmp) {
		JavaCode id = car(tmp);
		JavaCode stmt = jcStatement(jcSpaceSeqV(2, jcId(strCopy("import")), id));
		ids = listCons(JavaCode)(stmt, ids);
		tmp = cdr(tmp);
	}
	ids = listNReverse(JavaCode)(ids);
	listFree(JavaCode)(imps);
	return jcFile(NULL, jcId(className), ids, clss);
}

local void
gjInit(Foam foam, String name) 
{
	gjContext->lvl = 0;
	gjContext->formats = foam->foamUnit.formats;
	gjContext->constants = foamUnitConstants(foam);
}

local String 
gj0ClassName(Foam foam, String name)
{
	return strCopy(name);
}

local String 
gj0ClassDocumentation(Foam foam, String name) 
{
	return strPrintf("Generated by genjava - %s\n", name);
}


local JavaCodeList 
gj0DDef(Foam foam)
{
	JavaCodeList lst = listNil(JavaCode);
	int i;
	for (i=0; i<foamArgc(foam); i++) {
		Foam fm = foam->foamDDef.argv[i];
		JavaCode code = gj0Gen(fm);
		if (code != 0)
			lst = listCons(JavaCode)(code, lst);
	}
	return listNReverse(JavaCode)(lst);
}

local JavaCode
gj0Gen(Foam foam)
{
	switch (foamTag(foam)) {
	case  FOAM_Def:
		return gj0Def(foam);
	case FOAM_Set:
		return gj0Set(foam->foamSet.lhs, foam->foamSet.rhs);
	case FOAM_Par:
		return gj0Par(foam);
	case FOAM_Loc:
		return gj0Loc(foam);
	case FOAM_Seq:
		return gj0Seq(foam);
	case FOAM_SInt:
		return gj0SInt(foam);
	case FOAM_CCall:
		return gj0CCall(foam);
	default: 
		return gj0Default(foam);
	}

}

local JavaCode
gj0Def(Foam foam) {
	Foam lhs, rhs;
	JavaCode jc;
	
	assert(foamTag(foam) == FOAM_Def);

	lhs = foam->foamDef.lhs;
	rhs = foam->foamDef.rhs;
	switch (foamTag(lhs)) {
	case FOAM_Const:
		if (foamTag(rhs) == FOAM_Prog)
			jc = gj0Prog(lhs, rhs);
		else
			jc = gj0TopConst(lhs, rhs);
		break;
	default:
		if (gjContext->lvl == 0)
			jc = gj0ClosInit(lhs, rhs);
		else
			jc = gj0Set(lhs, rhs);
		break;
	}
	return jc;
}

local JavaCode 
gj0ClosInit(Foam lhs, Foam rhs)
{
	return gj0Default(lhs);
}

local JavaCode 
gj0TopConst(Foam lhs, Foam rhs)
{
	return 0;
}

/*
 * :: Prog
 */

typedef struct gjProgResult {
	JavaSigList sigs;
	JavaCode body;
	Bool hasGotos;
	JavaCodeList vars;
	JavaCodeList args;
	JavaCode retnType;
	JavaCode id;
	String comment;
	int modifiers;
} *GjProgResult;

local GjProgResult gj0ProgMain(Foam f);
local JavaCode     gj0ProgResultToJava(GjProgResult r);
local void         gj0ProgResultFree(GjProgResult r);
local void         gj0ProgResultFree(GjProgResult r);
local Bool         gj0ProgHasGotos(Foam f);

local JavaCode
gj0Prog(Foam lhs, Foam rhs)
{
	GjProgResult r;
	assert(foamTag(rhs) == FOAM_Prog);
	
	gj0ProgInit(lhs, rhs);
	r = gj0ProgMain(rhs);
	JavaCode code = gj0ProgResultToJava(r);
	gj0ProgResultFree(r);

	gj0ProgFini(lhs, rhs);
	
	return code;
}

local void
gj0ProgInit(Foam lhs, Foam prog)
{
	gjContext->lvl++;
	gjContext->progParams = prog->foamProg.params;
	gjContext->progLocals = prog->foamProg.locals;
	gjContext->progLhs    = lhs;
}

local void
gj0ProgFini(Foam lhs, Foam rhs)
{
	gjContext->lvl--;
	gjContext->progParams = NULL;
	gjContext->progLocals = NULL;
}

local GjProgResult
gj0ProgMain(Foam f)
{
	String methodName = gj0ProgMethodName(gjContext->progLhs);
	JavaCodeList args = gj0ProgCollectArgs(f);
	JavaCode body;
	JavaCodeList exns = gj0ProgExceptions();
	int modifiers = gj0ProgModifiers();
	Bool hasGotos = gj0ProgHasGotos(f);

	body = gj0ProgGenerateBody(f);
	
	GjProgResult r = (GjProgResult) stoAlloc(OB_Other, sizeof(*r));
	r->comment = 0;
	r->modifiers = modifiers;
	r->body = body;
	r->hasGotos = hasGotos;
	r->args = args;
	r->retnType = gj0ProgRetnType(f);
	r->id = jcId(methodName);
	return r;
}

local JavaCode     
gj0ProgResultToJava(GjProgResult r)
{
	JavaCode method;

	method = jcMethod(r->modifiers, r->comment, r->retnType,
			  r->id, NULL, r->args, NULL, r->body);

	return method;
}


local void         
gj0ProgResultFree(GjProgResult r)
{
	stoFree(r);
}


local JavaCode
gj0ProgRetnType(Foam rhs)
{
	return jcKeyword(symInternConst("void"));
}

local String 
gj0ProgMethodName(Foam var)
{
	Foam format;

	int idx = var->foamConst.index;
	assert(idx < foamArgc(gjContext->formats));
	format = gjContext->constants;

	return gj0Name("c", format, idx);
}

local JavaCodeList
gj0ProgCollectArgs(Foam prog)
{
	JavaCodeList lst;
	Foam fmt = prog->foamProg.params;
	int i;

	lst = listNil(JavaCode);
	
	for (i=0; i<foamDDeclArgc(fmt); i++) {
		Foam decl = fmt->foamDDecl.argv[i];
		String   name = gj0Name("p", fmt, i);
		JavaCode type = gj0Type(decl);
		lst = listCons(JavaCode)(jcParamDecl(0, type, jcId(name)), lst);
	}
	
	return listNReverse(JavaCode)(lst);
}

local Bool         
gj0ProgHasGotos(Foam f)
{
	return false;
}


/*
 * :: Java Types
 *
 * The mapping is as follows:
 * Char --> char
 * Bool --> boolean
 * Byye --> byte
 * HInt --> short
 * SInt --> int
 * SFlo --> float
 * DFlo --> double
 * Word --> foamj.FoamJ.Word
 * NOp  --> void [return types]
 * Clos --> foamj.FoamJ.Clos
 * Env  --> foamj.FoamJ.Env
 */
local JavaCode
gj0Type(Foam decl)
{
	return gj0TypeFrFmt(decl->foamDecl.type, decl->foamDecl.format);
}

local JavaCode
gj0TypeFrFmt(AInt id, AInt fmt)
{
	switch (id) {
	case FOAM_Char:
		return jcKeyword(symInternConst("char"));
	case FOAM_SInt:
		return jcKeyword(symInternConst("int"));
	case FOAM_Byte:
		return jcKeyword(symInternConst("byte"));
	case FOAM_NOp:
		return jcKeyword(symInternConst("void"));
	case FOAM_Clos:
		return jcImportedId(strCopy("foamj"),
				    strCopy("FoamJ.Clos"));
	case FOAM_Word:
		return jcImportedId(strCopy("foamj"),
				    strCopy("FoamJ.Word"));
	case FOAM_Env:
		return jcImportedId(strCopy("foamj"),
				    strCopy("FoamJ.Env"));
	case FOAM_Rec:
		return jcImportedId(strCopy("foamj"),
				    strCopy("FoamJ.Record"));
	default:
		return jcId(strCopy(foamStr(id)));
	}
}



local JavaCode
gj0ProgGenerateBody(Foam fm)
{
	return gj0Gen(fm->foamProg.body);
}

local JavaCodeList
gj0ProgExceptions()
{
	return listNil(JavaCode);
}

local int 
gj0ProgModifiers()
{
	return JCO_MOD_Private;
}



local String 
gj0MethodName(Foam var)
{
	int idx = var->foamConst.index;
	Foam format = gjContext->formats->foamDFmt.argv[idx];

	return gj0Name("c", format, idx);
}

local String
gj0Name(String prefix, Foam fmt, int idx)
{
	Foam decl;
	Buffer b = bufNew();

	assert(idx < foamArgc(fmt));
	decl = fmt->foamDDecl.argv[idx];
	bufPrintf(b, "%s%d", prefix, idx);

	if (strlen(decl->foamDecl.id) > 0) {
		bufPutc(b, '_');
		bufPuts(b, decl->foamDecl.id);
	}

	return bufLiberate(b);
}

local JavaCode 
gj0Set(Foam lhs, Foam rhs)
{
	switch (foamTag(lhs)) {
	case FOAM_Values:
	case FOAM_Fluid:
	default: {
		JavaCode lhsJ = gj0Gen(lhs);
		JavaCode rhsJ = gj0Gen(rhs);
		return jcAssign(lhsJ, rhsJ);
	}
		
	}
}

local JavaCode
gj0Par(Foam ref)
{
	Foam fmt = gjContext->progParams;
	return jcId(gj0Name("p", fmt, ref->foamPar.index));
}

local JavaCode
gj0Loc(Foam ref)
{
	Foam fmt = gjContext->progLocals;
	return jcId(gj0Name("t", fmt, ref->foamLoc.index));
}


local JavaCode 
gj0Seq(Foam seq)
{
	int i;
	JavaCodeList l = listNil(JavaCode);
	for (i=0; i<foamArgc(seq); i++) {
		JavaCode stmt = jcStatement(gj0Gen(seq->foamSeq.argv[i]));
		l = listCons(JavaCode)(stmt, l);
	}
	l = listNReverse(JavaCode)(l);
	return jcNLSeq(l);
}

/*
 * :: Casts
 */

/*
 * :: Method calls
 */


local JavaCode
gj0CCall(Foam call)
{
	String id = gj0CCallFindMethod(call);
	jcApply(jcId(id), gj0CCallCollectArgs(call));
}

local JavaCodeList
gj0CCallCollectArgs(Foam call)
{
	JavaCodeList args = listNil(JavaCode);
	foamIter(call, elt, {
			args = listCons(JavaCode)(gj0Gen(*elt), args);
		});
	return listNReverse(JavaCode)(args);
}

local String
gj0CCallFindMethod(Foam call) 
{
	String name = strCopy("ccall");
	suffix=strNConcat(name, gj0TypeAbbrevSym(call->type));
	foamIter(call, elt, {
			suffix=strNConcat(suffix, gj0TypeAbbrev(*elt));
		});
	return suffix;
}



String 
gj0TypeAbbrev(Foam foam)
{
	FoamTag tag = gj0FoamType(foam);
	switch (tag) {
	case FOAM_Rec:
		return "R";
	case FOAM_Arr:
		return "A";
	case FOAM_Word:
		return "W"
	case FOAM_SInt:
		return "I";
	case FOAM_SInt:
		return "H";
	default:
		return "?"
	}
}



/*
 * :: Integer Literals
 */


local JavaCode
gj0SInt(Foam foam)
{
	return jcLiteralInteger(foam->foamSInt.SIntData);
}


/*
 * :: Default code
 */

local JavaCode 
gj0Default(Foam foam) 
{
	SExpr sx = foamToSExpr(foam);
	String s = sxiFormat(sx);

	return jcSpaceSeqV(2, jcNull(), jcComment(s));
}

local FoamTag
gj0FoamType(Foam foam)
{
	FoamTag tag;
	AInt    extra;

	tag = foamExprType0(foam, gjContext->prog, 
			    gjContext->formats,
			    0, 0, &extra);
	
	return tag;
}
