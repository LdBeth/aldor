%% KeyWords: ToDo, UnknownRef, VerifyThis, ToBeContinued, ...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\head{chapter}{Using \asharp{} interactively}{asugUsingInteractive}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This chapter describes how to use a built-in interpreter to run 
\asharp{} programs interactively.  We shall assume that the reader is
familiar with at least the basic concepts of the \asharp{} programming
language.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{How to use the interpreter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The interpreter is built into the \asharp{} compiler.
It is used in two different contexts:

\begin{itemize}
\item running \asharp{} programs without compiling them to executable
files,
\item writing \asharp{} programs in interactive mode.
\end{itemize}

\subsection{Running programs with the interpreter (-g interp)}

Suppose you write an \asharp{} program \fname{foo.as}. One way to get it
running is with the command:

\begin{small}
\osprompt \asharpcmd{ -g run foo.as}
\end{small}

When you call the compiler with this option, it compiles the program
into a device-independent intermediate format called {\em Foam}
(stored, in this case, in the file
\fname{foo.ao}), which is then translated into C code (\fname{foo.c})
and compiled with the C compiler available on your platform.
Finally, the executable code generated by the C
compiler is executed\footnote{Note that using only the option
\option{-g run} causes all the intermediate files to be removed, once
the program is terminated. If you
want to keep them, then you should use, for example, \option{-Fao -Fx}.
See \chapref{asugOptions} or use the
\option{-hf} option to get help.}.
If you call the compiler with the \option{-g interp} option, e.g,

\begin{small}
\osprompt \asharpcmd{ -g interp foo.as}
\end{small}

the intermediate file \fname{foo.ao} is executed without any
call to the C compiler. Since the instructions are interpreted, and not
pure machine code instructions as when using \option{-g run}, execution
will generally be slower than in the first case. Despite the
low execution speed, there are reasons to use the interpreter
instead of the compiler:

\begin{itemize}
\item as the generation and the compilation of C code is unnecessary,
you can get faster responses using the interpreter if the program is 
not computationally time-expensive;
\item on some platforms, such as Intel 80x86 with Windows, there is no C
compiler included  with the operating system; in the absence of any C
compiler, the interpreter is the only way
% (apart from starting Lisp)
of running an \asharp{} program.
\end{itemize}

Using the interpreter is suggested especially for those who are
learning \asharp{}, as it provides a quick way of testing small
programs.  Note that all the compiler options can be used with
\option{-g interp}.
All optimisations except \option{-Qcc} are still effective, because
all optimisations in \asharp{} are
performed on the intermediate code. So, for example, if the compiler
is called using the \option{-Q3} option, as in:

\begin{small}
\osprompt \asharpcmd{ -Q3 -g interp foo.as}
\end{small}

the program will generally run faster than without the \option{-Q3}
option.

Note that the semantics of the language are fully preserved by the
interpreter.  The interpreter provides all of the \asharp{} language
features.

\subsection{Interactive mode \\ (-g loop)}

The {\bf interactive mode} provides an interactive environment in which
it is possible to define functions and domains, to use operations
provided by the library, to evaluate expressions and to use other
features.  Users who are familiar with programming in languages that are
usually interpreted, such as Lisp, already know the feeling of an
interactive environment and how it can be used to gain confidence in the
language, and to develop and debug more complex programs.

%%Note that the interactive environment provided with this version of the
%%compiler is still not completely reliable, partially due to the
%%difficulties met in making interactive a language originally designed
%%to be compiled. Despite these problems, it is a very useful tool for 
%%learning basic \asharp{} concepts, as well as developing and debugging
%%complex \asharp{} programs.
%%Unfortunately, the interactive environment provided with this version of the
%%compiler is still incomplete and not sufficiently reliable
%%(there are some known bugs documented at the end of this chapter).
%%Despite these problems, it is a very useful tool for learning basic \asharp{}
%%concepts, as well as developing and debugging complex \asharp{} programs.
The command line to start the compiler in interactive mode is:

\begin{small}
\osprompt \asharpcmd{ -g loop}
\end{small}

A prompt will appear:

{\small
\begin{verbatim}
%1 >> _
\end{verbatim}
}

At this point, you start typing the first line of your program, for
example:

{\small
\begin{verbatim}
%1 >> #include "aldor"
\end{verbatim}
}

After a few milliseconds the prompt appears again (the delay is due to the
interpreter loading the base library):

{\small
\begin{verbatim}
%1 >> #include "aldor"
%2 >> _
\end{verbatim}
}

A nicer output for types and values is available by include \fname{aldorinterp.as}:
{\small
\begin{verbatim}
%2 >> #include "aldorinterp"
\end{verbatim}
}

The number that appears immediately after \verb"%" is a serial number
which is incremented with each input line from the user.
As will be seen, this is useful when the \verb"history" mode is
\verb"on".  Now type:

{\small
\begin{verbatim}
%3 >> import from MachineInteger
%4 >> 1 + 1
\end{verbatim}
}


At this point the expression \verb"1 + 1" will be evaluated and the
answer is:
{\small
\begin{verbatim}
2 @ MachineInteger
\end{verbatim}
}


in which \verb"2" is the result of the expression and
\verb"@ MachineInteger" means that its type is \verb"MachineInteger".
To quit the interactive mode type:

{\small
\begin{verbatim}
%5 >> #quit
\end{verbatim}
}


When the interpreter starts, it looks in the current directory (the
directory from which the command line is being entered) for an
initialisation file. An initialisation file is any \asharp{} program
named \verb"aldorinit.as". If this file is present in the current
directory, it will be loaded and executed before the prompt appears.

An example initialisation file could be:

{\small
\begin{verbatim}
#include "aldor"
#include "aldorinterp"

-- Commonly used macros
MI ==> MachineInteger
I  ==> Integer
\end{verbatim}
}


Note: the interpreter will display a message:
\verb"Reading aldorinit.as..." if an initialisation file is read.

The majority of command line options are still active when
\option{-g loop} is used.  For example, the optimisation option:

\begin{small}
\osprompt \asharpcmd{ -Q3 -g loop}
\end{small}

will invoke the optimiser before interpreting the generated Foam
intermediate code, thereby affecting the execution speed.

We will now try a simple interactive session.
Note that all the lines which do not start with the prompt have not been
typed, but are part of the output.

{\small
\begin{verbatim}
%1 >> -- Example of interactive session --
%2 >> ------------------------------------
%3 >> -- Start by loading definitions
%4 >> #include "aldor"
%5 >> #include "aldorinterp"
%6 >> import from Integer
%7 >> 100
100 @ AldorInteger
%8 >> 100 + 100
200 @ AldorInteger
%9 >> f(x:Integer):Integer == if x=0 then 1 else x*f(x-1)
Defined f @ (x: AldorInteger) -> AldorInteger
%10 >> f 4
24 @ AldorInteger
%11 >> import from List Integer
%12 >> reverse
  () @ List(AldorInteger) -> List(AldorInteger)
%13 >> reverse [1,2,3,4,5]
[5,4,3,2,1] @ List(AldorInteger)
\end{verbatim}
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Terminology conventions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%We will now introduce some terminology which will be useful for the remainder
%%of this section.

%% \intdef{current expression} refers to the last expression entered in
%%interactive mode.
%%Example:
%%{\small
%%\begin{verbatim}
%%%4 >> 5 + 5   -- Here 5 + 5 is the `current expression'
%%\end{verbatim}
%%}


%%\intdef{current interpretation step} is equal to the number that appears in the
%%prompt. For example, if the prompt is \verb"\%10 $>>$", it means that the current
%%interpretation step is 10.

%%\intdef{print expr if possible} means that \verb"stdout $<<$ expr" could be
%%used in the same context and compiled/interpreted successfully.

%%Similarly, \intdef{wrap an assignment if possible} means that
%%\verb"new-var := expr", in which new-var is a new variable, could be used in
%%the same context and compiled/interpreted successfully.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Directives for the interactive mode}\label{asugInteractSyscmds}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section provides a full description of some language directives
available only in interactive mode\footnote{The directives available
in interactive mode will be ignored if they are encountered during
normal compilation.}.

The options available specifically for interactive mode are requested
using \ttin{\#int}.  A brief help message displaying all available
options may be obtained with:

\verb"#int help"

The options are as follows:
\begin{itemize}
\item help
\item verbose
\item history
\item confirm
\item timing
\item msg-limit
\item gc
\item options
\item cd
\item shell
\end{itemize}
These are described in detail below.

\mysubsect{} \verb"#int verbose [on | off]"

Default is: \verb"on".
        
When \verb"verbose" is \verb"on", the interpreter prints, if possible,
the value and the type of the current expression. 

Example:
        
{\small
\begin{verbatim}
%4 >> 4
4 @ MachineInteger
%5 >> 5 + 5
10 @ MachineInteger
%6 >> foo(x : String) : Boolean == empty? x
Defined foo @ (x: String) -> Boolean
\end{verbatim}
}
        
If the value of the expression is not printable (that is, its domain
does not export \verb"<<:(%, TextWriter) -> TextWriter") or if it has no
value at all (for instance, in \ttin{import from} statements), nothing
is displayed. 

\mysubsect{} \verb"#int history [on | off]"

Default is: \verb"off".


When \verb"history" is \verb"on", the interpreter wraps, if possible, 
an assignment around the current expression.
If, for example, \ttin{\%5} is the current interpretation step, the
prompt will change from 

\ttin{\%5 >>}

to

\ttin{\%5 :=}

which means that, if the current expression has a value, this is
assigned to a new variable named \ttin{\%5}. The variable \ttin{\%5} is
implicitly declared and its type is inferred from the type of
the right hand side.

%\pagebreak
Example:

{\small
\begin{verbatim}
%4 >> #int history on        -- history is on
%5 := MI ==> MachineInteger  -- no value is assigned to %5
%6 := import from MI         -- no value is assigned to %6
%7 := 5 + 5                  -- 10 is assigned to %7
10 @ MachineInteger
%8 := 10 + %7                -- you can use %7
20 @ MachineInteger
%9 := %7 := %7 - 5           -- 5 is assigned to %7 and %9
\end{verbatim}
}

\goodbreak
Notes:
\begin{enumerate}
\item At interpretation step 9, the right association rule for the
   \verb":=" operator in \asharp{} is observed.
\item At steps 5 and 6, since no value is assigned to \%5 or \%6, the
   variable names \%5 and \%6 are {\em not} introduced and trying to use
   them would generate an error message.
\end{enumerate}

\mysubsect{} \verb"#int confirm [on | off]"

Default is: \verb"on".


When \verb"confirm" is \verb"on", the interpreter asks for confirmation
before executing some operations that are illegal in the compiled
\asharp{} language. Typical cases are the redefinition of constants and
functions: according to the language definition, these cannot be
redefined --- but it may be useful to relax this rule in interactive
mode.

Suppose, for example, that you write a definition for a function
\ttin{foo}, later adding other functions using \ttin{foo}; at
some point you want to provide a better implementation for
\ttin{foo}: if your program is going to be compiled, then you can
simply edit the file where \ttin{foo} is defined and change it
but, unfortunately, this cannot be done if you wrote \ttin{foo}
interactively. This is why, in interactive mode, you can enter a new
definition for \ttin{foo}: a message will appear because you are
doing something that is not normally allowed in \asharp{} and, at this
point, you can confirm that you want to replace the old definition with
the new one.
If you do not want the message asking for a confirmation, you can enter:

\ttin{\#int confirm off}

in which case a positive answer is assumed
for each situation in which a confirmation would be needed.

%\pagebreak
Example:

{\small
\begin{verbatim}
%3 >> Int ==> Integer
%4 >> import from Int
%5 >> foo(x : Int) : Int == x
Defined foo @ (x: AldorInteger) -> AldorInteger
%6 >> foo(x : Boolean) : Boolean == not x       -- (see Note 1)
Defined foo @ (x: Boolean) -> Boolean
%7 >> foo(x : Int) : Int == x * x
Redefine ? (y/n): y                             -- (see Note 2)
foo redefined.
Defined foo @ (x: AldorInteger) -> AldorInteger
%8 >> foo 2
4 @ AldorInteger
\end{verbatim}
}

Notes:
\begin{enumerate}
\item In \asharp{} operators can be overloaded, so the definition at
step \ttin{\%6} is legal and does not need confirmation.
A function is redefined only if a new definition with exactly the same
signature is provided.
\item Answering \verb"n" causes the previous definition to be kept.
\end{enumerate}

It is useful to set this option \verb"off" when, for some reason, a file
is included a second time\footnote{Remember to use \ttin{\#reinclude} to
include a file that has already been included.}. If this file contains
some function definitions, you will not then be prompted to confirm each
of them.

\mysubsect{} \verb"#int timing [on | off]"

Default is: \verb+on+.

Displays a line after each operation detailing the time taken in the
compiler and the interpreter.  For example:
\begin{small}
\begin{verbatim}
%28 >> count := 0; for i in 1..1000 repeat count:=count+1
                           Comp: 0 msec, Interp: 10 msec
\end{verbatim}
\end{small}
To save space this option has been turned off in the examples given here.

\mysubsect{} \verb"#int msg-limit" {\it number}

Default is: 0 (no limit).

Set the maximum length, in characters, of \asharp{} messages. This is
useful because some of them, such as error messages, could consist of
several lines.  A value of 0 means that there is no limit. The
characters \ttin{...} at the end of the message will warn you that it
has been truncated.

Note that, if you limit the message length, then you will get
incomplete messages when you use the interactive mode as a
browser (see section \ref{I_mode_as_browse}).
You may also see long type-names cut off with \ttin{...} in error
messages.
To see the types in full, use 
\begin{verbatim}
#int options -M no-abbrev
\end{verbatim}

\mysubsect{} \verb"#int gc"

This command explicitly calls the garbage collector. 
After the execution, a message showing the amount of memory not released
is shown, with additional details if the verbose option is \verb"on".
This operation may take several seconds if the hardware is slow. 
Note that the garbage collection may occur as needed at other times,
even though you have not specifically requested it.

\mysubsect{} \verb"#int options" {\it command-line options}


Set one or more of the options normally available when the compiler is
called --- for example, optimisations.

Example:

\verb"#int options -Q3"

sets the optimisations \verb"on". Note that, since the interactive mode
will be slower for simple expressions if all the optimisations are
active but the functions defined are considerably faster, you might want
to turn optimisations such as \option{-Q3} \verb"on" before defining
time-intensive functions and to turn them \verb"off" or reset them to a
lower level (such as \option{-Q1} or \option{-Q0}) after the definition.

\mysubsect{} \verb"#int cd" {\it new-directory}

Change the current directory. This is useful if, for example,
you want to include files from another directory without
typing the path in the \ttin{\#include} directive.

Example: \verb"#int cd /tmp"

\mysubsect{} \verb'#int shell "'{\it shell-command}\verb'"'

Execute the quoted string as a shell command. This is useful, for
example, to start an editor session  without exiting the interpreter.

Example: \verb'#int shell "vi"'

will  start the \verb"vi" editor under Unix.

You can also start a child shell by passing the command which invokes
it as a command.
Under Unix, for example, you can say:

\verb'#int shell "csh"'

to start a \verb"csh" shell. To return to the interpreter,
type \verb"exit".

%\pagebreak
        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\widesection{Using the interactive mode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Multi-line input}

In order to provide as comfortable an interactive mode as possible,
the syntax of the \asharp{} language, as used interactively, differs
slightly from that of the compiled language.

Interactive mode is, by default, indentation sensitive.
As a consequence, you do not need a semicolon (\ttin{;}) at the end of
each statement --- the newline is identified as a separator.
This is different from non-interactive use, where you need
to use \verb"#pile" to get indentation sensitivity.

Multi-line input can be performed using braces or with a \ttin{==} as
the last symbol on a line. 

If you begin a definition with the line
{\small
\begin{verbatim}
 ...
%4 >> foo(x: Integer): Integer == {
\end{verbatim}
}
then the definition will be considered complete when the number of closing
braces (\ttin{\}}) matches the number of opening braces (\ttin{\{}) that
you entered. In this case, you must remember that braces always turn off
indentation sensitivity so you must use a semicolon (\ttin{;}) to
separate your statements.

If you enter
{\small
\begin{verbatim}
 ...
%4 >> foo(x: Integer): Integer ==
\end{verbatim}
}
\asharp{} interactive mode is smart enough to understand that you are
going to write the body of the function, so the line is not analysed
as a complete statement.  In this case you need to use
spaces or tabs to write your definition with appropriate indentation.
The definition will be complete when you start writing at
indentation level 0 again.
A quick way to terminate the definition of a function when
in indentation sensitive mode is to type \ttin{--} (an empty comment) at the
beginning of the line.

%This can be a little bit confusing, but it will avoid you a lot of
%syntax errors. 

We can show some examples. In the first one, a function
\ttin{arrToList} is defined using the indentation sensitive mode. Note that
\ttin{==} is last symbol at the end of line 8.

{\small
\begin{verbatim}
 ...
%5 >> import from Integer, Array Integer, List Integer
%6 >> -- no `;' needed at the end of the line.
%7 >> -- Defining a function using the indentation:
%8 >> arrToList(ar: Array Integer): List Integer ==
        -- the definition is not processed yet and the prompt does
        -- not appear, indicating that you can enter the body of
        -- the function.

        local ls : List Integer := empty   -- no `;'
        for x in ar repeat ls := cons(x,ls)
        ls -- return value

-- This comment at level 0 cause the definition to be processed.
Defined arrToList @ (ar: Array(AldorInteger)) -> List(AldorInteger)
%9 >> -- Here the prompt appears again.
%10 >> a : Array Integer := [1,2,3]
[1,2,3] @ Array(AldorInteger)
%11 >> arrToList a
[3,2,1] @ List(AldorInteger)

\end{verbatim}
}

In the second example the same function is defined using braces to get
multi-line input:

{\small
\begin{verbatim}
 ...
%8 >> arrToList(ar: Array Integer): List Integer == {
...        -- Indentation is not necessary, but we suggest using it
...        -- anyway to get a more readable code. Until the definition 
...        -- is complete, you need `;' at the end of each line.
...        -- (except when you write comments, of course).
...
...        local ls : List Integer := empty;
...        for x in ar repeat ls := cons(x,ls);
...        ls  -- only here, `;' is not necessary, following 
...            -- the language rules.
...
...-- Note that it is essential to match the opening
...-- brace to terminate the function definition -
...-- writing an unindented line does not suffice:
...}
Defined arrToList @ (ar: Array(AldorInteger)) -> List(AldorInteger)
%9 >> -- the prompt appears again.
\end{verbatim}
}

In this case the interpreter begins each newline with three dots to
indicate that it is in the middle of a definition.
Note that, since the definition is processed only when complete, all
the errors will be issued at that point. So, for example, if you
forget a terminator in the body of the function in the second example,
you will get a syntax error only when you type \ttin{\}}. This is true
when using either braces or indentation.

{\bf Note:} With interactive input it is often convenient to cut and
paste to and from a file (for example under X11 and Emacs). If
you are going to compile the file and you want to use fragments of code
from the interactive mode, you must either insert \ttin{\#pile} at the top
of your file or use braces when you (interactively) define multi-line
functions.

When you are using the indentation sensitive mode, the
interpreter will start to process the code when you add a line with
indentation level 0, {\em unless} this line starts another definition.
This makes cutting and pasting of code easier.
For example:

{\small
\begin{verbatim}
 ...
%4 >>
arrToList(ar: Array Integer): List Integer ==

        local ls : List Integer := empty   -- no `;'
        for x in ar repeat ls := cons(x,ls)
        ls -- return value


arrToList(ar: Array MachineInteger): List MachineInteger ==

        local ls : List MachineInteger := empty   -- no `;'
        for x in ar repeat ls := cons(x,ls)
        ls -- return value

--
 @ 
 with 
    ==  add ()

%5 >> 
\end{verbatim}
}


The previous example also demonstrates that: (1)~you can type
$<$Enter$>$ before defining the function (as in the first line), so that the
indentation is much nicer; (2)~the interactive mode is currently unable
to print a list of multiple definitions, so you get a strange message
when you close the double definition.

{\bf Note:} when the construct \ttin{with \{...\} = add \{...\}} is
typed on multiple lines, the braces must be placed as in:

{\small
\begin{verbatim}
       } == add {
\end{verbatim}
}

      and not as in:
{\small
\begin{verbatim}
       }
       == add {
\end{verbatim}
}

as this will cause a syntax error. 

\subsection{Initialisation file}

As explained above, when \asharp{} starts in interactive
mode, it looks in the current directory for a file called
\verb"aldorinit.as".
If this file is found, it will be read before the prompt
appears. Note that this only happens when \asharp{} starts in
interactive mode (\option{-g loop}), and not for the other modes,
such as \option{-g run} and \option{-g interp}.

The most common use
of the initialisation file is to define macros in order to
abbreviate the names of commonly used domains;
another use would be to set interactive options (such as
\verb"#int history on") that are \verb"off" by default. An example
initialisation file was given earlier.

There is also an alternative method to initialise the interactive
environment that, under certain circumstances, is more convenient. 
You may set the shell environment variable \ttin{INCPATH} to point to
a directory containing an \asharp{} initialisation file.
Suppose that you call this file
\fname{mylib.as};
then, when you start \asharp{} with \option{-g loop} you may type:

{\small
\begin{verbatim}
%1 >> #include "mylib"
\end{verbatim}
}


It is usually convenient to add the line:

{\small
\begin{verbatim}
#include "aldor"
\end{verbatim}
}


in the file \fname{mylib.as}, so that you need to include only this
file when you start the interactive mode.
Therefore you can initialise the interactive environment by using a file
\fname{aldorinit.as} in your current directory (that will be loaded
automatically when you start) or by using a file in the include path
that must be explicitly included when you start (or both).

\goodbreak
Two observations: 
\begin{enumerate}

\item You do not need to type the \ttin{.as} suffix when you include
a file.

\item You do not need to type the directory part of the name
when including a file in the include path.
Otherwise you do need to specify its directory.

\end{enumerate}

Here is another example of an initialisation file:

{\small
\begin{verbatim}
  #include "aldor"
  #include "aldorinterp"
  MI==>MachineInteger;
  #int verbose off
  #int history on
  out(x) ==> stdout << x;
\end{verbatim}
}

\subsection{Macros}

There are no restrictions for macros. They can be defined and used
at top level, as in:
 {\small
\begin{verbatim}
%1 >> MI ==> MachineInteger
%2 >> import from MI
\end{verbatim}
}

We recommend defining a set of macros to abbreviate long domain
names. These macros, which can be placed, for example, in the
initialisation file (see above), can reduce the number of typing errors.

\subsection{Running inside an editor}

If you use editors such as Emacs, we suggest running the
interactive mode in an editor inferior shell.
This will allow cutting and pasting of definitions into your text and 
maintaining a history of what was typed, so that in the event of a crash
occurring during the interactive mode session you do not lose what you
typed.

\subsection{Using the interactive mode as a browser}\label{I_mode_as_browse}

The interactive mode also may be used for finding the exports from
domains and categories.  Suppose that you want to use the \verb"Integer"
domain.  If you want to know its exports, simply type:

{\small
\begin{verbatim}
%3 >> Integer
\end{verbatim}
}

You will get:

{\small
\begin{verbatim}
 @ Join(
PrimitiveType with 
        coerce: BInt -> %
        coerce: % -> BInt
    ==  add ()
, 
IntegerType with export to IntegerSegment(%)
    ==  add ()
)
                                           Comp: 20 msec, Interp: 0 msec
\end{verbatim}
}

which is the type of Integer. Now type:

{\small
\begin{verbatim}
%4 >> IntegerType
\end{verbatim}
}

to get:

{\small
\begin{verbatim}
 @ Category == Join(OrderedArithmeticType, BooleanArithmeticType, HashType, InputType, OutputType, SerializableType) with 
        bit?: (%, MachineInteger) -> Boolean
        clear: (%, MachineInteger) -> %
        set: (%, MachineInteger) -> %
        coerce: MachineInteger -> %
        machine: % -> MachineInteger
        divide: (%, %) -> (%, %)
        mod: (%, MachineInteger) -> MachineInteger
        mod: (%, %) -> %
        quo: (%, %) -> %
        rem: (%, %) -> %
        even?: % -> Boolean
        odd?: % -> Boolean
        factorial: % -> %
        gcd: (%, %) -> %
        lcm: (%, %) -> %
        integer: Literal -> %
        length: % -> MachineInteger
        next: % -> %
        prev: % -> %
        nthRoot: (%, %) -> (Boolean, %)
        random: () -> %
        random: MachineInteger -> %
        shift: (%, MachineInteger) -> %
        shift!: (%, MachineInteger) -> %
        default 
                commutative?: Boolean == true
                lcm(a: %, b: %): % == ..
                next(a: %): % == ..
                prev(a: %): % == ..
                set(a: %, n: MachineInteger): % == ..
                clear(a: %, n: MachineInteger): % == ..
                hash(a: %): MachineInteger == ..
                odd?(a: %): Boolean == ..
                shift!(a: %, n: MachineInteger): % == ..
                ((a: %) mod (n: MachineInteger)): MachineInteger == ..
                even?(a: %): Boolean == ..
                factorial(n: %): % == ..
                ((a: %) mod (b: %)): % == ..
\end{verbatim}
}

and so on.

\subsection{Loading an \asharp{} file}

If you have an \asharp{} file, you can load it into the interactive
environment, so that, for example, you can interactively call and test
defined programs. There are two ways to do this:

\begin{enumerate}
\item You can use the \verb'#include "'{\em myfile\/}\verb'"' directive.
For example, when you start, instead of typing:

{\small
\begin{verbatim}
#include "aldor"
\end{verbatim}
}

you could type:

{\small
\begin{verbatim}
#include "myfile.as"
\end{verbatim}
}


(your file should then contain the \verb'#include "aldor"' directive).

\item If your operating system allows input redirection, you can use 
this to read a file.  For example, in Unix or DOS, you could type:

\osprompt \asharpcmd{ -g loop < myfile.as}

(Note that \verb"myfile.as" must respect the braces conventions for the
interactive mode, as explained before.)

\end{enumerate}

\subsection{The {\tt \#} symbol.}

In \asharp{} the \ttin{\#} symbol is a legal operator: some domains
(such as \verb"Array") export operations named \ttin{\#}.
The problem is that \ttin{\#} is also used to identify a preprocessor
directive, such as \ttin{\#include} or \ttin{\#int}. This can generate
confusion. Suppose, for example, that you type:

{\small
\begin{verbatim}
%1 >> #include "aldor"
%2 >> #include "aldorinterp"
%3 >> import from List MachineInteger, MachineInteger
%4 >> -- create a list of 5 elements
%5 >> l := [1,2,3,4,5]
[1,2,3,4,5] @ List(MachineInteger)
%6 >> #l   -- print the number of elements of `a'
\end{verbatim}
}


at this point you will get the message:
{\small
\begin{verbatim}
[L5 C1] #1 (Warning) Unknown system command.
\end{verbatim}
}


because the preprocessor is trying to interpret \ttin{\#a} as a directive.
To ensure the correct behaviour, you can simply add a space before
\ttin{\#} when it is not intended as a preprocessor directive, since a
line containing a preprocessor directive must start with the \ttin{\#}
(note that the prompt is not considered by the preprocessor).  In our
case, a space will be the first character of the line.  So, if you type:

{\small
\begin{verbatim}
%7 >>  #l  -- with ` ' before `#', you get...
5 @ MachineInteger
\end{verbatim}
}
that is, the correct answer.

\subsection{Labels}

Labels cannot be defined at top level. 
An input of the following kind is not allowed in interactive mode:
{\small
\begin{verbatim}
%1 >> @lab1
...
%n >> goto @lab1
\end{verbatim}
}

{\bf Note:} Actually, the interactive environment does not check if the
user is trying to jump to a label defined at the top level, so you
generally get a segmentation fault if you try to do this. Labels
{\em can} be used within function definitions.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \section{Using libraries in interactive mode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% ToDo.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\section{Limits of interpreter and interactive mode.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Import from Foreign C
% Browser not a Browser
%%ToDo

